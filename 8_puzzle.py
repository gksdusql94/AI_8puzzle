# -*- coding: utf-8 -*-
"""8 puzzle

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GvjHFPiXB-42fB-0cfDrnDvLLGEKwaku
"""

from collections import deque
import sys
import time
import resource

# Class representing the puzzle solver
class Solver(object):
    def __init__(self, initNode, searchType, input_board):
        # Initialize the solver with initial node and search type
        self.initNode = initNode
        self.searchType = searchType
        self.input_board = input_board

        # Initialize frontier based on search type
        if searchType == 'bfs':
            self.frontier = deque([initNode])  # Breadth-First Search uses a queue
        elif searchType == 'dfs':
            self.frontier = deque([initNode])  # Depth-First Search uses a stack
        elif searchType == 'ast':
            self.frontier = [(initNode.h, initNode)]  # A* Search uses a priority queue based on heuristic value

        # Initialize expanded set to keep track of explored states
        self.expandedSet = set([initNode.state])

        # Define the goal state and initialize other parameters
        self.goal = '0,1,2,3,4,5,6,7,8'
        self.path_to_goal = []
        self.goalFound = False
        self.nodes_expanded = 0
        self.max_search_depth = 0
        self.start_time = 0
        self.end_time = 0
        self.max_ram_usage = 0

    # Function to perform the tile exchange
    def exchange(self, board, n_bi, new_bi):
        new_board = board[:]
        new_board[n_bi] = board[new_bi]
        new_board[new_bi] = '0'
        return new_board

    # Heuristic function for A* search
    def heuristic(self, node):
        for i in range(len(node.board)):
            X = abs(i // 3 - node.board.index(str(i))// 3)
            Y = abs(i % 3 - node.board.index(str(i))% 3)
            d = X + Y
            node.h = d + node.h
        node.h = node.h + node.depth
        return node

    # Function to run the solver
    def run(self):
        print('Input:', self.searchType, ' '.join(self.input_board))

    # Main function to run the solver
    def run(self):
        self.start_time = time.time()
        while len(self.frontier) > 0:
            # Pop node from the frontier based on search type
            if self.searchType == 'bfs':
                node = self.frontier.popleft()
            elif self.searchType == 'dfs':
                node = self.frontier.pop()
            else:
                node = self.frontier.pop(0)[1]

            # Check if the goal is reached
            self.goal_test(node)
            if self.goalFound:
                return

        return print('no solution')

    # Function to test if a node is the goal state
    def goal_test(self, node):
        if node.state == self.goal:
            # If the goal state is found, record the solution
            self.goalFound = True
            self.end_time = time.time()
            return self.success(node)
        else:
            # If not, expand the node
            self.nodes_expanded += 1
            return self.exNodes(node)

    # Function to expand a node
    def exNodes(self, node):
        n_b = node.board
        n_bi = node.board.index('0')

        # Generate child nodes based on search type
        if self.searchType == 'bfs' or self.searchType == 'ast':
            if n_bi - 3 >= 0:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi - 3), node, 'Up'))
            if n_bi + 3 <= 8:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi + 3), node, 'Down'))
            if n_bi % 3 - 1 >= 0:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi - 1), node, 'Left'))
            if n_bi % 3 + 1 < 3:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi + 1), node, 'Right'))

        else:
            if n_bi % 3 + 1 < 3:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi + 1), node, 'Right'))
            if n_bi % 3 - 1 >= 0:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi - 1), node, 'Left'))
            if n_bi + 3 <= 8:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi + 3), node, 'Down'))
            if n_bi - 3 >= 0:
                self.addNode(Node(self.exchange(n_b, n_bi, n_bi - 3), node, 'Up'))

    # Function to add a new node to the frontier
    def addNode(self, newNode):
        if newNode.state not in self.expandedSet:
            self.expandedSet.add(newNode.state)
            if self.searchType == 'bfs' or self.searchType == 'dfs':
                self.frontier.append(newNode)
                self.max_search_depth = max(newNode.depth, self.max_search_depth)
            else:
                self.max_search_depth = max(newNode.depth, self.max_search_depth)
                newNode = self.heuristic(newNode)
                self.frontier.append((newNode.h, newNode))
                self.frontier.sort(key=lambda tup: tup[0])

    # Function to handle successful search
    def success(self, node):
        successfulPath = self.getPath(node)
        with open('output.txt', 'w') as f: # Change mode to 'w' for writing
            f.write('Input: {} {}\n'.format(self.searchType, ' '.join(self.input_board)))
            f.write('path_to_goal: {}\n'.format(successfulPath))
            f.write('cost_of_path: {}\n'.format(len(successfulPath)))
            f.write('nodes_expanded: {}\n'.format(self.nodes_expanded))
            f.write('search_depth: {}\n'.format(node.depth))
            f.write('max_search_depth: {}\n'.format(self.max_search_depth))
            f.write('running_time: {}\n'.format(self.end_time - self.start_time))
            max_ram_usage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss) / 1024 / 1024
            f.write('max_ram_usage: {} MB\n\n'.format(max_ram_usage))

        print('Statistics written to output.txt')
        # Print the statistics as well
        print('path_to_goal:', successfulPath)
        print('cost_of_path:', len(successfulPath))
        print('nodes_expanded:', self.nodes_expanded)
        print('search_depth:', node.depth)
        print('max_search_depth:', self.max_search_depth)
        print('running_time:', self.end_time - self.start_time)
        print('max_ram_usage:', max_ram_usage, 'MB')

    # Function to retrieve the path to the goal
    def getPath(self, node):
        while node.parent:
            self.path_to_goal.append(node.action)
            node = node.parent
        self.path_to_goal.reverse()
        return self.path_to_goal

# Class representing a node in the search tree
class Node(object):
    def __init__(self, board, parentNode, action):
        # Initialize node with board state, parent node, action taken, and depth
        self.state = ','.join(board)
        self.board = board
        self.h = 0

        if parentNode == False:
            self.parent = False
            self.depth = 0
            self.action = ''
        else:
            self.parent = parentNode
            self.depth = parentNode.depth + 1
            self.action = action

    def __str__(self):
        return self.state

import sys

# Validate command-line arguments
if len(sys.argv) != 3:
    sys.stderr.write('Error: must have 3 command arguments"\n')
    sys.exit()

if sys.argv[1] not in ['bfs', 'dfs', 'ast']:
    sys.stderr.write('Error: <method> argument must be "bfs", "dfs", "ast"\n')
    sys.exit()

input_board = sys.argv[2].split(',')

if len(input_board) != 9:
    sys.stderr.write('Error: input board must be 0 ~ 8 numbers')
    sys.exit()

ordered_board = sorted(map(int, input_board))
for i, element in enumerate(ordered_board):
    if element != i:
        sys.stderr.write('Error: input board must contain all 0 ~ 8 numbers')
        sys.exit()

searchType = sys.argv[1]
initNode = Node(input_board, False, '')
mySolution = Solver(initNode, searchType, input_board)
mySolution.run()